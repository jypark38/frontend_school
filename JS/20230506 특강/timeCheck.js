let start = Date.now();

const result = (x) => {
  console.log(`${x}가 실행되는데 걸리는 시간 : ${Date.now() - start}`);
};

// const blocking = () => {
//   let i = 0;
//   while (i < 99999999) {
//     i++;
//   }
//   return 'blocking finished';
// };

const asyncBlocking = () => {
  return new Promise((resolve, reject) => {
    let i = 0;
    while (i < 9999999) {
      i++;
    }
    resolve('blocking finished');
  });
};

result('동기식 코드1');

// 가장 마지막 실행. 메크로 테스크의 특성으로 다른 함수가 다 실행된 뒤에 실행되는 것을 볼 수 있다.
setTimeout(() => {
  result('setTimeout finished');
}, 0);

// Promise 객체를 만드는 과정은 동기적으로 진행됩니다!
// result(asyncBlocking());

// setTimeout제외하고서 가장 마지막에 출력된다. 즉, promise는 비동기가 아니지만, 메서드인 then이 비동기적으로 실행되는 것을 볼 수 있다.
result(asyncBlocking().then((text) => result(text)));

result('동기식 코드2');

//* NOTE
/**
 * 자바스크립트는 싱글스레드이다. 함수들이 컨베이어벨트처럼 순서대로 실행이 되는데, 만약 이 사이에 너무 오래 걸리는 함수가 있다면 그 함수 때문에 뒤에 있는 동작이 다 밀리게 된다. 그래서 자바스크립트 엔진은 사이드 스레드로 그 함수를 준비될 때까지 빼준 후에 실행 될 수 있을 때 시킵니다.
 * 근데 이러면 그 메인과 사이드의 함수가 부딪힐 수 있지 않을까?
 * 이때 발생하는 문제를 바로 'race condition problems'라고 한다.
 *
 * 브라우저는 싱글쓰레드로 한번에 하나의 코드만 처리할 수 있기 때문에 이렇게 동시에 여러가지 코드가 실행되는 상황을 막아야한다. 이때 등장하는 것이 'task queues' 이때 큐(queue)는 자료구조의 일종으로 어떤 처리를 순서대로 해야할 때 사용하는 자료구조이다.(FIFO)
 *
 * 브라우저는 메인스레드에서 실행해야하는 어떤 함수가 나타나면 이벤트 루프에게 얘기해 이 함수를 테스크 큐에 등록한다. 그리고 실행해야하는 함수의 차례가 오면 이벤트 루프는 함수를 실행한다.
 * 1. 대기시간동안 사이드 스레드에 위치
 * 2. 시간이 다 되면 이벤트 루프가 콜백 함수를 테스크 큐에 등록
 * 3. 테스크 큐에서 콜백함수의 차례가 되면 메인스레드에서 함수를 실행
 *
 * 테스크 큐는 크게 두개의 종류가 있다.
 * 1. 메크로 테스크 (Macro Tasks)
 * 2. 마이크로 테스크 (Micro Tasks)
 *
 * setTimeout 같은 메소드는 메크로 테스크큐에 등록되고 실행되기 전에 다른 코드가 실행되고 있다면 끝날 때까지 기다린 다음 실행된다. 차례를 지키는 것.
 * 하지만 마이크로 테스크 큐에 등록된 코드들은 차례가 되면 바로 메인스레드에서 실행된다. 즉 마이크로 테스크큐에 등록된 코드들은 메크로 테스크 큐에 등록된 함수보다 더 높은 우선순위를 가지며, 이 코드들이 실행 될 때는 메크로 테스크 큐의 코드들의 실행을 배제한다고 볼 수 있다.
 * 그리고 우리가 사용하는 Promise 객체의 콜백 함수들은 모두 마이크로 테스크 큐에 등록된다.
 */